#!/usr/bin/env node
"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/cli.ts
var import_commander = require("commander");
var import_fs = require("fs");
var import_path = __toESM(require("path"));
var import_pg = require("pg");

// src/lib/schemaGenerator.ts
var pgToTsType = (pgType, isNullable) => {
  const types = {
    "character varying": "string",
    varchar: "string",
    text: "string",
    integer: "number",
    bigint: "number",
    numeric: "number",
    decimal: "number",
    boolean: "boolean",
    timestamp: "Date",
    timestamptz: "Date",
    date: "Date",
    jsonb: "Record<string, unknown>",
    json: "Record<string, unknown>",
    uuid: "string"
  };
  const tsType = types[pgType] || "unknown";
  return isNullable ? `${tsType} | null` : tsType;
};
function generateTableTypes(tableName, pool) {
  return __async(this, null, function* () {
    const query = `
    SELECT column_name, data_type, is_nullable
    FROM information_schema.columns
    WHERE table_name = $1
    ORDER BY ordinal_position;
  `;
    const result = yield pool.query(query, [tableName]);
    const columns = result.rows;
    let typeDefinition = `export interface ${tableName.charAt(0).toUpperCase() + tableName.slice(1)} {
`;
    columns.forEach((col) => {
      const isNullable = col.is_nullable === "YES";
      const tsType = pgToTsType(col.data_type, isNullable);
      typeDefinition += `  ${col.column_name}: ${tsType};
`;
    });
    typeDefinition += "}";
    return typeDefinition;
  });
}

// src/cli.ts
function printProgress(current, total) {
  const barWidth = 30;
  const progress = Math.round(current / total * barWidth);
  const bar = "▓".repeat(progress) + "░".repeat(barWidth - progress);
  const percentage = Math.round(current / total * 100);
  process.stdout.write(
    `\r[${bar}] ${percentage}% | ${current}/${total} tables`
  );
}
function generateTypes(options) {
  return __async(this, null, function* () {
    if (!options.url) {
      console.error("Error: Database URL is required");
      process.exit(1);
    }
    const pool = new import_pg.Pool({
      connectionString: options.url
    });
    try {
      (0, import_fs.mkdirSync)(options.output, { recursive: true });
      if (options.table) {
        process.stdout.write(`Generating types for ${options.table} `);
        const dots = setInterval(() => process.stdout.write("."), 500);
        const tableType = yield generateTableTypes(options.table, pool);
        clearInterval(dots);
        process.stdout.write("\n");
        const outputPath = import_path.default.join(options.output, `${options.table}.ts`);
        (0, import_fs.writeFileSync)(outputPath, tableType);
        console.log(`✓ Types generated for table ${options.table}`);
      } else {
        process.stdout.write("Fetching tables...\n");
        const tables = yield pool.query(`
       SELECT table_name
       FROM information_schema.tables
       WHERE table_schema = 'public'
     `);
        let typesContent = "// Generated by retool-db-types\n\n";
        let count = 0;
        for (const { table_name } of tables.rows) {
          printProgress(count, tables.rows.length);
          const tableType = yield generateTableTypes(table_name, pool);
          typesContent += tableType + "\n\n";
          count++;
        }
        printProgress(tables.rows.length, tables.rows.length);
        process.stdout.write("\n");
        const outputPath = import_path.default.join(options.output, "index.ts");
        (0, import_fs.writeFileSync)(outputPath, typesContent);
        console.log("\n✓ Types generated successfully!");
      }
    } catch (error) {
      console.error(
        "\n❌ Error:",
        error instanceof Error ? error.message : "Unknown error"
      );
      process.exit(1);
    } finally {
      yield pool.end();
    }
  });
}
var program = new import_commander.Command().name("retool-db-types").description("Generate TypeScript types from your Retool database").option("-u, --url <url>", "Database connection URL").option("-o, --output <path>", "Output directory", "./src/types").option("-t, --table <table>", "Specific table to generate types for").addHelpText(
  "after",
  `
Examples:
 $ retool-db-types --url="postgresql://..." --table=users
 $ retool-db-types --url="postgresql://..." --output=./types
`
).action(generateTypes);
program.parse();
//# sourceMappingURL=cli.js.map