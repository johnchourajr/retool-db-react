{"version":3,"sources":["../src/cli.ts","../src/lib/schemaGenerator.ts"],"sourcesContent":["import { Command } from \"commander\";\nimport { mkdirSync, writeFileSync } from \"fs\";\nimport path from \"path\";\nimport { Pool } from \"pg\";\nimport { generateTableTypes } from \"./lib/schemaGenerator\";\n\nconst program = new Command();\n\nprogram\n  .name(\"retool-db-types\")\n  .description(\"Generate TypeScript types from your Retool database\")\n  .option(\"-u, --url <url>\", \"Database connection URL\")\n  .option(\"-o, --output <path>\", \"Output directory\", \"./src/types\")\n  .option(\"-t, --table <table>\", \"Specific table to generate types for\")\n  .parse(process.argv);\n\nconst options = program.opts();\n\nasync function generateTypes() {\n  if (!options.url) {\n    console.error(\"Error: Database URL is required\");\n    process.exit(1);\n  }\n\n  const pool = new Pool({\n    connectionString: options.url,\n  });\n\n  try {\n    // Create output directory if it doesn't exist\n    mkdirSync(options.output, { recursive: true });\n\n    if (options.table) {\n      // Generate types for specific table\n      const tableType = await generateTableTypes(options.table, pool);\n      const outputPath = path.join(options.output, `${options.table}.ts`);\n      writeFileSync(outputPath, tableType);\n      console.log(`Types generated for table ${options.table}`);\n    } else {\n      // Generate types for all tables\n      const tableQuery = `\n        SELECT table_name\n        FROM information_schema.tables\n        WHERE table_schema = 'public'\n      `;\n\n      const tables = await pool.query(tableQuery);\n\n      let typesContent = \"// Generated by retool-db-types\\n\\n\";\n\n      for (const { table_name } of tables.rows) {\n        const tableType = await generateTableTypes(table_name, pool);\n        typesContent += tableType + \"\\n\\n\";\n      }\n\n      const outputPath = path.join(options.output, \"index.ts\");\n      writeFileSync(outputPath, typesContent);\n      console.log(\"Types generated for all tables!\");\n    }\n  } catch (error) {\n    console.error(\"Error generating types:\", error);\n    process.exit(1);\n  } finally {\n    await pool.end();\n  }\n}\n\ngenerateTypes();\n","import { Pool } from \"pg\";\n\ninterface ColumnInfo {\n  column_name: string;\n  data_type: string;\n  is_nullable: string;\n}\n\nconst pgToTsType = (pgType: string, isNullable: boolean): string => {\n  const types: Record<string, string> = {\n    \"character varying\": \"string\",\n    varchar: \"string\",\n    text: \"string\",\n    integer: \"number\",\n    bigint: \"number\",\n    numeric: \"number\",\n    decimal: \"number\",\n    boolean: \"boolean\",\n    timestamp: \"Date\",\n    timestamptz: \"Date\",\n    date: \"Date\",\n    jsonb: \"Record<string, unknown>\",\n    json: \"Record<string, unknown>\",\n    uuid: \"string\",\n  };\n\n  const tsType = types[pgType] || \"unknown\";\n  return isNullable ? `${tsType} | null` : tsType;\n};\n\nexport async function generateTableTypes(\n  tableName: string,\n  pool: Pool,\n): Promise<string> {\n  const query = `\n    SELECT column_name, data_type, is_nullable\n    FROM information_schema.columns\n    WHERE table_name = $1\n    ORDER BY ordinal_position;\n  `;\n\n  const result = await pool.query<ColumnInfo>(query, [tableName]);\n  const columns = result.rows;\n\n  let typeDefinition = `export interface ${tableName.charAt(0).toUpperCase() + tableName.slice(1)} {\\n`;\n\n  columns.forEach((col) => {\n    const isNullable = col.is_nullable === \"YES\";\n    const tsType = pgToTsType(col.data_type, isNullable);\n    typeDefinition += `  ${col.column_name}: ${tsType};\\n`;\n  });\n\n  typeDefinition += \"}\";\n  return typeDefinition;\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,uBAAwB;AACxB,gBAAyC;AACzC,kBAAiB;AACjB,gBAAqB;;;ACKrB,IAAM,aAAa,CAAC,QAAgB,eAAgC;AAClE,QAAM,QAAgC;AAAA,IACpC,qBAAqB;AAAA,IACrB,SAAS;AAAA,IACT,MAAM;AAAA,IACN,SAAS;AAAA,IACT,QAAQ;AAAA,IACR,SAAS;AAAA,IACT,SAAS;AAAA,IACT,SAAS;AAAA,IACT,WAAW;AAAA,IACX,aAAa;AAAA,IACb,MAAM;AAAA,IACN,OAAO;AAAA,IACP,MAAM;AAAA,IACN,MAAM;AAAA,EACR;AAEA,QAAM,SAAS,MAAM,MAAM,KAAK;AAChC,SAAO,aAAa,GAAG,MAAM,YAAY;AAC3C;AAEA,SAAsB,mBACpB,WACA,MACiB;AAAA;AACjB,UAAM,QAAQ;AAAA;AAAA;AAAA;AAAA;AAAA;AAOd,UAAM,SAAS,MAAM,KAAK,MAAkB,OAAO,CAAC,SAAS,CAAC;AAC9D,UAAM,UAAU,OAAO;AAEvB,QAAI,iBAAiB,oBAAoB,UAAU,OAAO,CAAC,EAAE,YAAY,IAAI,UAAU,MAAM,CAAC,CAAC;AAAA;AAE/F,YAAQ,QAAQ,CAAC,QAAQ;AACvB,YAAM,aAAa,IAAI,gBAAgB;AACvC,YAAM,SAAS,WAAW,IAAI,WAAW,UAAU;AACnD,wBAAkB,KAAK,IAAI,WAAW,KAAK,MAAM;AAAA;AAAA,IACnD,CAAC;AAED,sBAAkB;AAClB,WAAO;AAAA,EACT;AAAA;;;ADhDA,IAAM,UAAU,IAAI,yBAAQ;AAE5B,QACG,KAAK,iBAAiB,EACtB,YAAY,qDAAqD,EACjE,OAAO,mBAAmB,yBAAyB,EACnD,OAAO,uBAAuB,oBAAoB,aAAa,EAC/D,OAAO,uBAAuB,sCAAsC,EACpE,MAAM,QAAQ,IAAI;AAErB,IAAM,UAAU,QAAQ,KAAK;AAE7B,SAAe,gBAAgB;AAAA;AAC7B,QAAI,CAAC,QAAQ,KAAK;AAChB,cAAQ,MAAM,iCAAiC;AAC/C,cAAQ,KAAK,CAAC;AAAA,IAChB;AAEA,UAAM,OAAO,IAAI,eAAK;AAAA,MACpB,kBAAkB,QAAQ;AAAA,IAC5B,CAAC;AAED,QAAI;AAEF,+BAAU,QAAQ,QAAQ,EAAE,WAAW,KAAK,CAAC;AAE7C,UAAI,QAAQ,OAAO;AAEjB,cAAM,YAAY,MAAM,mBAAmB,QAAQ,OAAO,IAAI;AAC9D,cAAM,aAAa,YAAAA,QAAK,KAAK,QAAQ,QAAQ,GAAG,QAAQ,KAAK,KAAK;AAClE,qCAAc,YAAY,SAAS;AACnC,gBAAQ,IAAI,6BAA6B,QAAQ,KAAK,EAAE;AAAA,MAC1D,OAAO;AAEL,cAAM,aAAa;AAAA;AAAA;AAAA;AAAA;AAMnB,cAAM,SAAS,MAAM,KAAK,MAAM,UAAU;AAE1C,YAAI,eAAe;AAEnB,mBAAW,EAAE,WAAW,KAAK,OAAO,MAAM;AACxC,gBAAM,YAAY,MAAM,mBAAmB,YAAY,IAAI;AAC3D,0BAAgB,YAAY;AAAA,QAC9B;AAEA,cAAM,aAAa,YAAAA,QAAK,KAAK,QAAQ,QAAQ,UAAU;AACvD,qCAAc,YAAY,YAAY;AACtC,gBAAQ,IAAI,iCAAiC;AAAA,MAC/C;AAAA,IACF,SAAS,OAAO;AACd,cAAQ,MAAM,2BAA2B,KAAK;AAC9C,cAAQ,KAAK,CAAC;AAAA,IAChB,UAAE;AACA,YAAM,KAAK,IAAI;AAAA,IACjB;AAAA,EACF;AAAA;AAEA,cAAc;","names":["path"]}